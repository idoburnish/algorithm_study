## 문제 유형
- 분할 정복
- 구현

## 코드
```cpp

int map[MAX][MAX] ={0};
int cnt = 0;

bool isdrain(int x, int y, int len){
    for(int i=x;i<x+len;i++){
        for(int j=y;j<y+len;j++){
            if(map[i][j]!=0) return true;
        }
    }
    return false;
}

void solve(int x,int y, int len){
    cnt++;
    int halflen = len/2;
    if(!isdrain(x,y,halflen)) {
        map[x+halflen-1][y+halflen-1] = cnt;
    }
    if(!isdrain(x,y+halflen,halflen)) {
        map[x+halflen-1][y+halflen] = cnt;
    }
    if(!isdrain(x+halflen,y,halflen)) {
        map[x+halflen][y+halflen-1] = cnt;
    }

    if(!isdrain(x+halflen,y+halflen,halflen)) {
        map[x+halflen][y+halflen] = cnt;
    }
    if(len == 2) return;
    solve(x,y,halflen);
    solve(x+halflen,y,halflen);
    solve(x,y+halflen,halflen);
    solve(x+halflen,y+halflen,halflen);
}
```

## 로직
1. map에 drain 위치를 저장한다.
2. 정사각형을 4등분하여 각 사분면의 정사각형에 drain이 존재하는지 체크한다. (isdrain 함수 => 이때, 모든 사분면의 기준은 왼쪽 아래 좌표를 기준으로한다.)
3. drain이 존재하지 않는다면, 중앙에 맞닿는 타일에 동일한 cnt값을 채운다.
4. 정사각형을 4등분하여 체크하는 과정을 반복한다(분할정복)
5. 정사각형 len이 2라면 모든 타일을 채운 후, 종료 처리를 해주어야 한다. (return)

![image](https://user-images.githubusercontent.com/69031678/168891750-356b5e2a-202b-484e-b053-11c2f185f558.png)


## 리뷰
small 문제기 때문에 사이즈가 1, 2일때만 고려하면 되지만 분할정복,재귀 처리를 통해 사이즈가 큰 타일에도 적용할 수 있도록 문제를 풀어주었다.
구현하는데는 큰 무리가 없었지만 규칙을 찾기 어려워서 L-트로미노에 대해 찾아보았다. (https://blogshine.tistory.com/228)
분할정복에서는 규칙을 잘 찾고 범위를 제대로 나누어 수행할 수 있도록 구현해주는 것이 핵심이라는 것을 느꼈다.

## 문제 유형
- 문자열
- 분할 정복

## 코드
```cpp
bool check(char paper[],int s,int e)
{
    if(s>=e) return true;
    int l = s;
    int r = e;
    while(l<r)
    {
        if(paper[l]==paper[r]) return false;
        l++;
        r--;
    }
    return check(paper,s,r-1);
}

```

## 로직
- 종이를 절반씩 접게 되면, 항상 접은 부분을 중심으로 양쪽에는 반대로 접힌 흔적이 남게 된다. 
- 종이의 길이가 홀수이고, 가운데를 기준으로 대칭인 자리의 합이 1인 경우에 규칙을 성립한다. 또한, 가운데를 기준으로 양 옆의 숫자들 또한 성립해야한다.



![image](https://user-images.githubusercontent.com/69031678/168490089-f4d2a267-9eca-4b4c-8629-76531ce46898.png)


## 리뷰
종이를 접어 생기는 흔적은 항상 중앙에 생기게 된다. 그리고 생긴 흔적을 중심으로 항상 반대로 접히게 된다.
예를 들어 문자열이 1000110 인 경우, 처음 접은 흔적은 1000110 정중앙에 위치한 0이다.
그 다음 접은 흔적은 1000110 가운데 0을 기준으로 나눠진 3개의 흔적 중 중앙에 위치한 0과 1이다.
마지막으로 접은 흔적은 1000110 남은 4개의 흔적이 된다. 따라서 이 문자열은 종이를 총 3번 접었으며, 
우리는 이렇게 종이를 접을 때마다 나올 수 있는 문자열인지 확인하면 문제를 해결할 수 있다.
이러한 규칙을 떠올리기가 어려웠다.
